<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>
    Deform vector graphics
    </title>
    
    <script src="web-gui/jquery-1.10.2.min.js" type="text/javascript"></script>
    <script src="web-gui/Blob.js" type="text/javascript"></script>
    <script src="web-gui/FileSaver.js" type="text/javascript"></script>
    <script src="web-gui/snap.svg-min.js" type="text/javascript"></script>
    
    <link rel="stylesheet" href="web-gui/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css"> -->
    <!-- <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap-theme.min.css"> -->
    <!-- <script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script> -->
    <script src="web-gui/bootstrap.min.js"></script>

<style type="text/css">
body
{
    margin: 9px;
}
#svg-holder
{
    margin: 10px 45px;
    /* min-height: 100px; */
    
    position: relative;
    
    font-size: 200%;
    font-weight: bold;
}
.absolute0
{
    position: absolute;
    left: 0;
    top: 0;
}
.empty
{
    outline: 9px dashed #ccc;
}
.droppable
{
    outline: 9px dashed #0c0;
}
.not-droppable
{
    outline: 9px dashed #c00;
}

.tt
{
    font-family: monospace;
}

#file-info h1
{
    margin-top: 10px;
}
</style>

</head>
<body>
<div class="container">

<div class="row">

<div id="file-info" class="col-sm-12">
<h1><span id="filename" class="tt">Drag an SVG file here.</span>
<button type="button" id="save-button" class="btn btn-default" disabled>Save SVG</button>
</h1>
</div>

</div>
<div class="row">

<div id="control-point-constraints" class="col-sm-6 text-muted" disabled>
<span class="lead">Control point &lt;<span id="path_index" class="tt">null</span>, <span id="segment_index" class="tt">null</span>&gt;:</span>
<div class="checkbox">
<label>Position fixed <input id="fixed" type="checkbox" disabled /></label>
</div>
<div class="form-group">
Constraint type:
        <select id="continuity" disabled>
        <option value="C0" selected>C0</option>
        <option value="C1">C1</option>
        <option value="G1">G1</option>
        <option value="A">Fixed Angle</option>
        </select>
</div>
</div>

</div>

<hr />
</div>

<div id="svg-holder" class="text-center">
<div id="svg-file" class="absolute0"></div>
<div id="svg-overlay" class="absolute0"></div>
</div>

<script type='text/javascript'>
///
/// Constants.
///
var kDebugging = false;
// var kDragDropFeedbackSelector = "#svg-holder";
var kDragDropFeedbackSelector = "body";
var kWebSocketURI = "ws://localhost:9000";
var kFakeWebSocket = true;

///
/// Global variables.
///
// For each path, for each cubic end point, a dictionary { 'fixed': true|false, 'continuity': 'C0|C1|G1|A' }
var gPathsControlPointConstraints = null;
// The WebSocket.
var gSocket = null;


///
/// Global functions.
///
function isDroppable( evt )
{
    var files = evt.dataTransfer.files;
    if( files.length === 1 && files[0].type === 'image/svg+xml' )
    {
        return true;
    }
    return false;
}
function displayDroppable( evt )
{
    console.log("displayDroppable")
    
    evt.preventDefault();
    
    var droppable = isDroppable( evt );
    var add = ( droppable ? "droppable" : "not-droppable" );
    var remove = ( !droppable ? "droppable" : "not-droppable" );
    
    $(kDragDropFeedbackSelector).removeClass( remove );
    $(kDragDropFeedbackSelector).addClass( add );
}

function setupWebSocket()
{
    if( kFakeWebSocket )
    {
        console.log( "Using a fake WebSocket" );
        gSocket = {};
        gSocket.send = function( msg ) { console.log( "SEND " + msg ); }
        return;
    }
    
    gSocket = new WebSocket( kWebSocketURI );
    gSocket.onopen = function(evt) { console.log( 'CONNECTED' ); };
    gSocket.onclose = function(evt) { console.log( 'DISCONNECTED' ); };
    gSocket.onmessage = function(evt) { handleSocketMessage( evt.data ) };
    gSocket.onerror = function(evt) { console.log( 'ERROR: ' + evt.data ); };
}
function handleSocketMessage( data )
{
    // TODO
    console.log( 'Received data: ' + data );
}
function sendPathsForPrecomputation()
{
    // I want JSON encoding.
    "use strict";
    
    // Send all paths over the websocket.
    // TODO Q: Should I figure out which one is the biggest one?
    //         A heuristic would be to take the one with the largest bounding box.
    
    var paths_info = [];
    $('#svg-file path').each( function( index, path ) {
        var cubic_points = [];
        
        /// Adapted from: http://stackoverflow.com/questions/8053487/scripting-path-data-in-svg-reading-and-modifying
        // http://www.w3.org/TR/SVG/paths.html#__svg__SVGAnimatedPathData__normalizedPathSegList
        // See also path.pathSegList and path.animatedPathSegList and path.animatedNormalizedPathSegList
        var segments = path.pathSegList;
        for( var i = 0; i < segments.numberOfItems; ++i )
        {
            var pathSeg = segments.getItem(i);
            // http://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathSeg
            switch( pathSeg.pathSegType )
            {
                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                    if( 0 !== i ) console.log( "This is bad. Move-to should only appear as the first thing in a path." );
                    cubic_points.push( [ pathSeg.x, pathSeg.y ] );
                    break;
                
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                    cubic_points.push( [ pathSeg.x1, pathSeg.y1 ] );
                    cubic_points.push( [ pathSeg.x2, pathSeg.y2 ] );
                    cubic_points.push( [ pathSeg.x, pathSeg.y ] );
                    break;
                
                case SVGPathSeg.PATHSEG_CLOSEPATH:
                    // Nothing to do. This is here because we complain on default.
                    break;
                
                default:
                    console.log( "We shouldn't see pathSeg.pathSegType: " + pathSeg.pathSegType );
                    break;
            }
        }
        
        // Save the bounding box area of the path.
        var bbox = Snap.path.getBBox( path.getAttribute('d') );
        var bbox_area = bbox.width * bbox.height;
        
        var closed = segments.getItem( segments.numberOfItems - 1 ).pathSegType === SVGPathSeg.PATHSEG_CLOSEPATH;
        
        paths_info[index] = {
            'bbox_area': bbox_area,
            'closed': closed,
            'cubic_bezier_chain': cubic_points
            };
        } );
    
    gSocket.send( "paths-info " + JSON.stringify( paths_info ) );
}
function sendHandlePositions()
{
    "use strict";
    
    var handle_positions = [];
    for( var i = 0; i < gHandles.length; ++i )
    {
        handle_positions.push( gHandles[i].pos );
    }
    
    gSocket.send( "handle-positions " + JSON.stringify( handle_positions ) );
}
function sendHandleTransformation( handle_index )
{
    "use strict";
    
    gSocket.send( "handle-transform " + JSON.stringify( [ i, gHandles[i].transform ] ) );
}
function sendControlPointConstraintsChanged( path_index, segment_index )
{
    "use strict";
    
    gSocket.send( "control-point-constraint " + JSON.stringify( [ path_index, segment_index, gPathsControlPointConstraints[ path_index ][ segment_index ] ] ) );
}

function setupFileIO()
{
    // In order to use jQuery event handling with drag-and-drop events,
    // we have to tell jQuery to include it:
    jQuery.event.props.push( "dataTransfer" );
    
    $(kDragDropFeedbackSelector).addClass( "empty" );
    
    $( window ).on( 'dragover', displayDroppable );
    // The dragenter and dragleave events are hard to use, because they fire when any child
    // element is entered. Instead, we use 'dragover' and let 'drop' take care of removing
    // the css classes.
    // $( window ).on( 'dragleave', function() { $(kDragDropFeedbackSelector).removeClass( "droppable not-droppable" ); } );
    
    $( window ).on( 'drop', function( evt ) {
        evt.preventDefault();
        
        $(kDragDropFeedbackSelector).removeClass( "droppable not-droppable" );
        
        if( !isDroppable( evt ) ) return;
        
        var file = evt.dataTransfer.files[0];
        var reader = new FileReader();
        
        reader.onloadend = function(evt) {
            if (evt.target.readyState == FileReader.DONE) {
                var svg_text = reader.result;
                
                $("#filename").text( file.name );
                $("#filename").removeClass( "text-muted" );
                
                loadSVG( svg_text );
                
                $("#save-button").prop( "disabled", false );
            }
            }
        
        reader.readAsBinaryString(file);
        } );
    
    $("#save-button").click( function() {
        var svg_to_save = $("#svg-file > svg");
        if( svg_to_save.length === 0 )
        {
            alert( "No SVG to save. This button should be disabled." );
            return;
        }
        
        // NOTE: svg_to_save[0].outerHTML does not seem to work with SVG in Chrome.
        //       It is also less correct, because we lose the header comments
        //       that were in the file before the <svg> tag.
        var blob = new Blob([ svg_to_save.parent().html() ], {type: "image/svg+xml"});
        saveAs( blob, $('#filename').text() );
        } );
}

function loadSVG( svg_text )
{
    // Attach the SVG to its node.
    $('#svg-file').html( svg_text );
    
    // Remove the "empty" visual indicator.
    $(kDragDropFeedbackSelector).removeClass( "empty" );
    
    // Set the width and height of the SVG area.
    var svg_holder = $('#svg-holder');
    
    /*
    // Get the actual SVG dom element with [0] rather than a jquery object.
    // UPDATE: This gets the bounding box size of the contents, not the size of the actual
    //         SVG-defined viewport, which is what is used for drawing.
    var svg = $('#svg-file > svg')[0];
    svg_holder.width( svg.getBBox().width );
    svg_holder.height( svg.getBBox().height );
    */
    
    var svg = $('#svg-file > svg');
    svg_holder.width( svg.width() );
    svg_holder.height( svg.height() );
    
    // Normalize SVG paths by converting them entirely to cubic bezier.
    normalizeSVG();
    
    // Send SVG to the backend.
    sendPathsForPrecomputation();
    
    // Setup UI
    createUIForSVG();
}

function normalizeSVG()
{
    // Iterate over all paths, replacing them with normalized versions of themselves.
    var svg = $('#svg-file path').each( function( index, path ) {
        
        // When a path is closed, Snap drops the final Z and adds a
        // cubic bezier line connecting the last and first point.
        // That is unnecessary when the last and first point were already equal.
        // Check for this case and remove such a final bezier curve.
        // Afterwards, put the last Z back.
        var closed = path.pathSegList.getItem( path.pathSegList.numberOfItems - 1 ).pathSegType === SVGPathSeg.PATHSEG_CLOSEPATH;
        
        // Snap.path.toCubic() converts paths entirely to absolute cubic beziers.
        path.setAttribute( 'd', Snap.path.toCubic( path.getAttribute('d') ).toString() );
        
        var segments = path.pathSegList;
        var pathSeg0 = segments.getItem( 0 );
        var pathSegN1 = segments.getItem( segments.numberOfItems - 1 );
        var pathSegN2 = segments.getItem( segments.numberOfItems - 2 );
        
        if( closed )
        {
            // Check if the first and last points were the same.
            if( pathSeg0.x === pathSegN2.x && pathSeg0.y === pathSegN2.y )
            {
                segments.replaceItem( path.createSVGPathSegClosePath(), segments.numberOfItems - 1 );
            }
            else
            {
                segments.appendItem( path.createSVGPathSegClosePath() );
            }
        }
        } );
}

function createUIForSVG()
{
    console.log( "createUIForSVG()" );
    
    // Duplicate the loaded SVG, so we get the right viewport, and then clear its contents.
    $( '#svg-overlay' ).html( $('#svg-file > svg').clone().empty() );
    var ui = Snap( '#svg-overlay > svg' );
    ui.clear();
    
    gPathsControlPointConstraints = [];
    
    disableControlPointControls();
    
    var paths = $( '#svg-file > svg path' );
    // For each path, make a small clickable circle that brings up a popup menu.
    paths.each( function( index, path ) {
        
        gPathsControlPointConstraints.push( [] );
        
        /// Adapted from: http://stackoverflow.com/questions/8053487/scripting-path-data-in-svg-reading-and-modifying
        // http://www.w3.org/TR/SVG/paths.html#__svg__SVGAnimatedPathData__normalizedPathSegList
        // See also path.pathSegList and path.animatedPathSegList and path.animatedNormalizedPathSegList
        var segments = path.pathSegList;
        
        function createControlPointHandle( path_index, segment_index, pathSeg )
        {
            gPathsControlPointConstraints[ path_index ][ segment_index ] = { 'fixed': false, 'continuity': 'C0' };
            
            var c = ui.circle( pathSeg.x, pathSeg.y, 10. );
            c.attr({
                fill: "#5555da",
                stroke: "#000",
                strokeWidth: 2.
                });
            
            c.click( function() {
                // Reset colors of all circles.
                $('#svg-overlay circle').attr( "fill", '#5555da' );
                
                // If the point is currently selected, deselect it.
                if( controlPointIsSelected( path_index, segment_index ) )
                {
                    disableControlPointControls();
                }
                else
                {
                    // Set up controls for the control point.
                    setupControlPointControls( path_index, segment_index );
                    
                    // Set color of selected circle.
                    c.attr({ fill: '#da5555' });
                }
                } );
        }
        
        for( var i = 0; i < segments.numberOfItems; ++i )
        {
            var pathSeg = segments.getItem(i);
            // http://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathSeg
            switch( pathSeg.pathSegType )
            {
                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                    // TODO Q: Skip the first "move to" point if the last command is close path?
                    // A1: Yes. Otherwise I have two sets of constraints for the same point.
                    // A2: No. Skip the last curveTo point, so that indexing is easier.
                    // if( 0 === i && segments.getItem( segments.numberOfItems - 1 ).pathSegType === SVGPathSeg.PATHSEG_CLOSEPATH ) break;
                    createControlPointHandle( index, i, pathSeg );
                    break;
                
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                    // A2: No. Skip the last curveTo point, so that indexing is easier.
                    if( i+1 < segments.numberOfItems && segments.getItem( i + 1 ).pathSegType === SVGPathSeg.PATHSEG_CLOSEPATH ) break;
                    createControlPointHandle( index, i, pathSeg );
                    break;
                
                case SVGPathSeg.PATHSEG_CLOSEPATH:
                    // Nothing to do. This is here because we complain on default.
                    break;
                
                default:
                    console.log( "We shouldn't see pathSeg.pathSegType: " + pathSeg.pathSegType );
                    break;
            }
        }
        } );
}

function controlPointIsSelected( path_index, segment_index )
{
    return(
        parseInt( $('#path_index').text() ) === path_index &&
        parseInt( $('#segment_index').text() ) === segment_index
        );
}
function setupControlPointControls( path_index, segment_index )
{
    $('#path_index').text( path_index );
    $('#segment_index').text( segment_index );
    
    // We really only have to enable these controls the first time.
    var controls = $('#control-point-constraints');
    controls.removeClass( 'text-muted' );
    controls.find( 'select, input' ).prop( "disabled", false );
    
    var settings = gPathsControlPointConstraints[ path_index ][ segment_index ];
    controls.find( '[value=' + settings.continuity + ']' ).prop( 'selected', true );
    controls.find( 'input' ).prop( 'checked', settings.fixed );
}
function disableControlPointControls()
{
    $('#path_index').text( 'null' );
    $('#segment_index').text( 'null' );
    
    // We really only have to enable these controls the first time.
    var controls = $('#control-point-constraints');
    controls.addClass( 'text-muted' );
    controls.find( 'select, input' ).prop( "disabled", true );
}
function setupGlobalUI()
{
    $('#continuity').change( function() {
        
        var path_index = parseInt( $('#path_index').text() );
        var segment_index = parseInt( $('#segment_index').text() );
        
        gPathsControlPointConstraints[ path_index ][ segment_index ].continuity = this.value;
        
        sendControlPointConstraintsChanged( path_index, segment_index );
        } );
    
    $('#fixed').change( function() {
        var path_index = parseInt( $('#path_index').text() );
        var segment_index = parseInt( $('#segment_index').text() );
        
        gPathsControlPointConstraints[ path_index ][ segment_index ].fixed = this.checked;
        
        sendControlPointConstraintsChanged( path_index, segment_index );
        } );
}


///
/// Initialization.
///
$(document).ready( function() {
    
    setupWebSocket();
    
    setupFileIO();
    
    setupGlobalUI();
});
</script>
</body>
</html>
