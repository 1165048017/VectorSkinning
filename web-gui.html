<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>
    Deform vector graphics
    </title>
    
    <script src="web-gui/jquery-1.10.2.min.js" type="text/javascript"></script>
    <script src="web-gui/Blob.js" type="text/javascript"></script>
    <script src="web-gui/FileSaver.js" type="text/javascript"></script>
    <script src="web-gui/snap.svg-min.js" type="text/javascript"></script>
    
    <link rel="stylesheet" href="web-gui/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css"> -->
    <!-- <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap-theme.min.css"> -->
    <!-- <script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script> -->
    <script src="web-gui/bootstrap.min.js"></script>

<style type="text/css">
body
{
    margin: 9px;
}
#svg-holder
{
    margin: 10px 45px;
    /* min-height: 100px; */
    
    position: relative;
    
    font-size: 200%;
    font-weight: bold;
}
.absolute0
{
    position: absolute;
    left: 0;
    top: 0;
}
.empty
{
    outline: 9px dashed #ccc;
}
.droppable
{
    outline: 9px dashed #0c0;
}
.not-droppable
{
    outline: 9px dashed #c00;
}

.tt
{
    font-family: monospace;
}

#file-info h1
{
    margin-top: 10px;
}

.background-selected
{
    background: #ffc;
}

/*
Magic to make columns equal height.
From: http://stackoverflow.com/questions/19695784/how-can-i-make-bootstrap-columns-all-the-same-height
But with 100% instead of 99999px as in:
From: http://stackoverflow.com/questions/19089384/twitter-bootstrap-3-two-columns-full-height
*/
[class*="col-"]
{
    margin-bottom: -100%;
    padding-bottom: 100%;
}
.row
{
    overflow: hidden; 
}
</style>

</head>
<body>

<div id="svg-holder" class="text-center">
<div id="svg-file" class="absolute0"></div>
<div id="svg-overlay-beziers-deformed" class="absolute0"></div>
<div id="svg-overlay-target" class="absolute0"></div>
<div id="svg-overlay-constraints" class="absolute0"></div>
<div id="svg-overlay-handles" class="absolute0"></div>
</div>

<div class="container">

<hr />

<div class="row">

<div id="file-info" class="col-sm-12">
<h1><span id="filename" class="tt">Drag an SVG file here.</span>
<button type="button" id="save-button" class="btn btn-default" disabled>Save SVG</button>
</h1>
</div>

</div>
<div class="row" style="margin: 20px 0">

<div id="control-point-constraints" class="col-sm-4 text-muted equal-height">
<span class="lead">Control point &lt;<span id="path_index" class="tt">null</span>, <span id="segment_index" class="tt">null</span>&gt;:</span>
<div class="checkbox">
<label>Position fixed <input id="fixed" type="checkbox" disabled /></label>
</div>
<div class="form-group">
Constraint type:
        <select id="continuity" disabled>
        <option value="C0" selected>C0</option>
        <option value="C1">C1</option>
        <option value="G1">G1</option>
        <option value="A">Fixed Angle</option>
        <option value="None">Open End</option>
        </select>
</div>
</div>
<div id="handle-widgets" class="col-sm-4 text-muted equal-height">
<span class="lead">Handle &lt;<span id="handle_index" class="tt">null</span>&gt;:</span>
<div class="form-group">
Transformation type:
        <select id="transformation" disabled>
        <option value="translation" selected>translation</option>
        <option value="rotation">rotation</option>
        <option value="scaling">scaling</option>
        </select>
</div>
<div>
<table class="table table-hover table-condensed table-bordered">
<tr>
    <td><input type="text" class="form-control" name="a" value="?" disabled></td>
    <td><input type="text" class="form-control" name="c" value="?" disabled></td>
    <td><input type="text" class="form-control" name="e" value="?" disabled></td>
</tr>
<tr>
    <td><input type="text" class="form-control" name="b" value="?" disabled></td>
    <td><input type="text" class="form-control" name="d" value="?" disabled></td>
    <td><input type="text" class="form-control" name="f" value="?" disabled></td>
</tr>
<tr>
    <td><span class="form-control" disabled>0</span></td>
    <td><span class="form-control" disabled>0</span></td>
    <td><span class="form-control" disabled>1</span></td>
</tr>
</table>
</div>
</div>

<div id="toggles" class="col-sm-3 col-sm-offset-1">
<span class="lead">Toggles</span>

<div class="checkbox"><label>BBW <input id="isBBWEnabled" type="checkbox" checked/></label></div>
<div class="checkbox"><label>Save overlays <input id="kSaveDecorations" type="checkbox"/></label></div>
<div class="checkbox"><label>Show target curves <input id="showTargetCurves" type="checkbox" /></label>
    <div class="checkbox"><label>Live update <input id="liveTargetCurves" type="checkbox" disabled /></label></div>
</div>
<div class="checkbox"><label>Show control points <input id="showDeformedControlPoints" type="checkbox" /></label></div>
<div class="checkbox"><label>Arc Length Parameterization <input id="usingArcLengthParameterization" type="checkbox" /></label></div>

<!-- <button type="button" id="setup-button" class="btn btn-default" disabled></button> -->

</div>

</div>
</div>

<script type='text/javascript'>
///
/// Constants.
///
var kDebugging = false;
var kProfiling = false;
// Whether to also save the SVG decorations to disk when the user clicks the save button.
// UPDATE: Access this via: $('#kSaveDecorations').prop('checked')
// var kSaveDecorations = true;
// Whether to also save the global variables to disk when the user clicks the save button.
var kSaveGlobals = true;
// var kDragDropFeedbackSelector = "#svg-holder";
var kDragDropFeedbackSelector = "body";
var kWebSocketURI = "ws://localhost:9123";
var kFakeWebSocket = false;


///
/// Global variables.
///
var gInputSVGText = null;
// For each path, for each cubic end point, a dictionary { 'fixed': true|false, 'continuity': 'C0|C1|G1|A' }
var gPathsControlPointConstraints = null;
// The index of the largest path.
var gLargestPath = null;
// An array of handles, where each handle is a dictionary { 'pos': [ x,y ], 'transform': Snap.Matrix }
var gHandles = [];
// The WebSocket.
var gSocket = null;
// enable bbw
// UPDATE: Access this via: $('#isBBWEnabled').prop('checked')
// var isBBWEnabled = true;


///
/// Global functions.
///
function isDroppable( evt )
{
    var files = evt.dataTransfer.files;
    
    // We can handle one SVG and one JSON, alone or together.
    
    // How many SVG?
    var countSVG = 0, countJSON = 0;
    for( var i = 0; i < files.length; ++i )
    {
        if( files[i].type === 'image/svg+xml' ) countSVG += 1;
        if( files[i].type === 'application/json' ) countJSON += 1;
    }
    
    return countSVG <= 1 && countJSON <= 1 && files.length > 0 && files.length <= 2;
}
function displayDroppable( evt )
{
    console.log("displayDroppable")
    
    evt.preventDefault();
    
    var droppable = isDroppable( evt );
    var add = ( droppable ? "droppable" : "not-droppable" );
    var remove = ( !droppable ? "droppable" : "not-droppable" );
    
    $(kDragDropFeedbackSelector).removeClass( remove );
    $(kDragDropFeedbackSelector).addClass( add );
}

function setupWebSocket()
{
    if( kFakeWebSocket )
    {
        console.log( "Using a fake WebSocket" );
        gSocket = {};
        gSocket.send = function( msg ) { console.log( "SEND " + msg ); }
        return;
    }
    
    gSocket = new WebSocket( kWebSocketURI );
    gSocket.onopen = function(evt) { console.log( 'CONNECTED' ); };
    gSocket.onclose = function(evt) { console.log( 'DISCONNECTED' ); };
    gSocket.onmessage = function(evt) { receiveSocketMessage( evt.data ) };
    gSocket.onerror = function(evt) { console.log( 'ERROR: ' + evt.data ); };
}
function receiveSocketMessage( data )
{
    "use strict";
    
    if( kDebugging ) console.log( 'Received data: ' + data );
    
    var start;
    if( kProfiling ) start = new Date().getTime();
    
    // Javascript check if a string starts with another string.
    // From: http://stackoverflow.com/questions/646628/javascript-startswith
    if( data.lastIndexOf( 'control-point-constraint ', 0 ) === 0 )
    {
        var update = JSON.parse( data.substring( 'control-point-constraint '.length ) );
        gPathsControlPointConstraints[ update[0] ][ update[1] ] = update[2];
    }
    else if( data.lastIndexOf( 'paths-positions ', 0 ) === 0 )
    {
        updatePaths( JSON.parse( data.substring( 'paths-positions '.length ) ) );
    }
    else if( data.lastIndexOf( 'update-target-curve ', 0 ) === 0 )
    {
        updateTargetCurve( JSON.parse( data.substring( 'update-target-curve '.length ) ) );
    }
    else
    {
        console.log( 'UNKNOWN MESSAGE RECEIVED: ' + data );
    }
    
    if( kProfiling )
    {
    	var end = new Date().getTime();
		console.log( 'receiveSocketMessage took: ' + ( end - start )/1000. );
    }
}
// updatePaths() updates the paths in the SVG.
// Its parameter is an array containing updated versions
// of the 'cubic_bezier_chain' field, one for each path,
// as packaged for sendPathsForPrecomputation().
function updatePaths( new_paths_points )
{
    var paths = $( '#svg-file > svg path' );
    // Because of subpaths and compound paths, we can't compare paths.length with new_paths_points.length.
    
    var new_path_index = -1;
    var new_path_offset = 0;
    for( var svg_path_index = 0; svg_path_index < paths.length; ++svg_path_index )
    {
        var path = paths[svg_path_index];
        var segments = path.pathSegList;
        
        for( var i = 0; i < segments.numberOfItems; ++i )
        {
            var pathSeg = segments.getItem(i);
            // http://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathSeg
            switch( pathSeg.pathSegType )
            {
                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                    // Handle subpaths and compound paths by creating a new path every
                    // time we see a move-to.
                    // NOTE: This will be wrong if there is a close-path *not* followed
                    //       by a move-to.
                    new_path_index += 1;
                    new_path_offset = 0;
                    
                    pathSeg.x = new_paths_points[new_path_index][new_path_offset][0];
                    pathSeg.y = new_paths_points[new_path_index][new_path_offset][1];
                    new_path_offset += 1;
                    break;
                
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                    pathSeg.x1 = new_paths_points[new_path_index][new_path_offset][0];
                    pathSeg.y1 = new_paths_points[new_path_index][new_path_offset][1];
                    new_path_offset += 1;
                    
                    pathSeg.x2 = new_paths_points[new_path_index][new_path_offset][0];
                    pathSeg.y2 = new_paths_points[new_path_index][new_path_offset][1];
                    new_path_offset += 1;
                    
                    pathSeg.x = new_paths_points[new_path_index][new_path_offset][0];
                    pathSeg.y = new_paths_points[new_path_index][new_path_offset][1];
                    new_path_offset += 1;
                    
                    break;
                
                default:
                    console.log( "We shouldn't see pathSeg.pathSegType: " + pathSeg.pathSegType );
                    break;
            }
        }
    }
    
    // Update the circle widgets for the deformed curve overlay.
    // UPDATE: Only do it if they're visible.
    // From: http://stackoverflow.com/questions/178325/testing-if-something-is-hidden-with-jquery
    if( $('#svg-overlay-beziers-deformed').is(":visible") )
    {
        updateDeformedBezierOverlay();
    }
    // It's a hack to put this here instead of on the drag handler, but we
    // batch drag events.
    if( $('#svg-overlay-target').is(":visible") && $('#liveTargetCurves').prop('checked') )
    {
        sendHandleDragFinished();
    }
}
function updateDeformedBezierOverlay()
{
    var circle_inner = $( '#svg-overlay-beziers-deformed .control-point-inner' );
    var circle_outer = $( '#svg-overlay-beziers-deformed .control-point-handle' );
    var tangent_lines = $( '#svg-overlay-beziers-deformed .control-point-tangents' );
    
    var circle_inner_index = 0;
    var circle_outer_index = 0;
    var tangent_lines_index = 0;
    
    var paths = $( '#svg-file > svg path' );
    for( var svg_path_index = 0; svg_path_index < paths.length; ++svg_path_index )
    {
        var path = paths[svg_path_index];
        var segments = path.pathSegList;
        
        for( var i = 0; i < segments.numberOfItems; ++i )
        {
            var pathSeg = segments.getItem(i);
            // http://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathSeg
            switch( pathSeg.pathSegType )
            {
                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                    circle_outer.eq( circle_outer_index ).attr({
                        cx: pathSeg.x,
                        cy: pathSeg.y
                        });
                    circle_outer_index += 1;
                    
                    tangent_lines.eq( tangent_lines_index ).attr({
                        x1: pathSeg.x,
                        y1: pathSeg.y
                        });
                    
                    break;
                
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                    circle_inner.eq( circle_inner_index ).attr({
                        cx: pathSeg.x1,
                        cy: pathSeg.y1
                        });
                    circle_inner_index += 1;
                    
                    circle_inner.eq( circle_inner_index ).attr({
                        cx: pathSeg.x2,
                        cy: pathSeg.y2
                        });
                    circle_inner_index += 1;
                    
                    circle_outer.eq( circle_outer_index ).attr({
                        cx: pathSeg.x,
                        cy: pathSeg.y
                        });
                    circle_outer_index += 1;
                    
                    tangent_lines.eq( tangent_lines_index ).attr({
                        x2: pathSeg.x1,
                        y2: pathSeg.y1
                        });
                    tangent_lines_index += 1;
                    
                    tangent_lines.eq( tangent_lines_index ).attr({
                        x1: pathSeg.x2,
                        y1: pathSeg.y2
                        });
                    tangent_lines.eq( tangent_lines_index ).attr({
                        x2: pathSeg.x,
                        y2: pathSeg.y
                        });
                    tangent_lines_index += 1;
                    
                    // The first point of the next line.
                    if( tangent_lines_index < tangent_lines.length )
                    {
                        tangent_lines.eq( tangent_lines_index ).attr({
                            x1: pathSeg.x,
                            y1: pathSeg.y
                            });
                    }
                    
                    break;
                
                default:
                    console.log( "We shouldn't see pathSeg.pathSegType: " + pathSeg.pathSegType );
                    break;
            }
        }
    }
}
// updateTargetCurve() updates the target curves in the SVG.
// Its parameter is an array containing an array of dictionaries,
// once for each path. Each dictionary contains two entries:
// 'target-curve-polyline' which is an array of polyline points and
// 'energy' which is the energy value for the polyline.
function updateTargetCurve( new_paths_energies )
{
    // Duplicate the loaded SVG, so we get the right viewport, and then clear its contents.
    $( '#svg-overlay-target' ).html( $('#svg-file > svg').clone().empty() );
    var ui = Snap( '#svg-overlay-target > svg' );
    ui.clear();
    
    // Let's normalize by max energy. We need to take a pass in advance to get it.
    var maxEnergy = 0.;
    for( var path_index = 0; path_index < new_paths_energies.length; ++path_index )
    {
        for( var segment_index = 0; segment_index < new_paths_energies[path_index].length; ++segment_index )
        {
            maxEnergy = Math.max( maxEnergy, new_paths_energies[path_index][segment_index].energy );
        }
    }
    if( maxEnergy === 0. ) maxEnergy = 1.;
    
    // Add a path for everything in the list.
    for( var path_index = 0; path_index < new_paths_energies.length; ++path_index )
    {
        var path_info = new_paths_energies[ path_index ];
        for( var segment_index = 0; segment_index < path_info.length; ++segment_index )
        {
            var target_curve_info = path_info[ segment_index ];
            var pts = target_curve_info['target-curve-polyline'];
            var energy = target_curve_info['energy'];
            
            var path_string = 'M' + pts[0][0] + ',' + pts[0][1];
            for( var si = 1; si < pts.length; ++si )
            {
                path_string = path_string + 'L' + pts[si][0] + ',' + pts[si][1];
            }
            
            var path = ui.path( path_string );
            path.attr({
                class: 'target-curve-polyline',
                stroke: 'rgb( 100%, 0%, ' + ( 100 - Math.max( 0, Math.min( 100, Math.round( 100*energy/maxEnergy ) ) ) ) + '% )',
                strokeWidth: 3,
                fillOpacity: 0.,
                strokeDasharray: "20,10,5,5,5,10"
                });
        }
    }
}
/*
Given an array of [x,y] coordinates, returns the area of the axis-aligned bounding box
containing the points.
Returns 0 for an empty array of points.
*/
function bounding_box_area_for_points( points )
{
    if( points.length === 0 )
    {
        console.log( "bounding_box_area_for_points() called with no points. returning 0." )
        return 0;
    }
    
    var minx = points[0][0];
    var miny = points[0][1];
    var maxx = minx;
    var maxy = miny;
    
    for( var i = 1; i < points.length; ++i )
    {
        minx = Math.min( minx, points[i][0] );
        miny = Math.min( miny, points[i][1] );
        
        maxx = Math.max( maxx, points[i][0] );
        maxy = Math.max( maxy, points[i][1] );
    }
    
    return (maxx - minx)*(maxy - miny);
}
function sendPathsForPrecomputation()
{
    // I want JSON encoding.
    "use strict";
    
    // Send all paths over the websocket.
    // Q: Should I figure out which one is the biggest one?
    // A: A heuristic that might work is to take the one with the largest bounding box.
    
    var paths_info = [];
    function append_path( cubic_points )
    {
        if( cubic_points.length < 4 )
        {
            console.error( "append_path() received something too short." );
            return;
        }
        if( (cubic_points.length-1) % 3 )
        {
            console.error( "append_path() received the wrong number of points." );
            return;
        }
        
        // Save the bounding box area of the path.
        var bbox_area = bounding_box_area_for_points( cubic_points );
        
        var first_point = cubic_points[0];
        var last_point = cubic_points[ cubic_points.length-1 ];
        
        var closed = first_point[0] == last_point[0] && first_point[1] == last_point[1];
        // NOTE: Closed curves will have the last point the same as the first.
        
        paths_info.push({
            'bbox_area': bbox_area,
            'closed': closed,
            'cubic_bezier_chain': cubic_points
            });
    }
    
    $('#svg-file path').each( function( index, path ) {
        var cubic_points = [];
        
        /// Adapted from: http://stackoverflow.com/questions/8053487/scripting-path-data-in-svg-reading-and-modifying
        // http://www.w3.org/TR/SVG/paths.html#__svg__SVGAnimatedPathData__normalizedPathSegList
        // See also path.pathSegList and path.animatedPathSegList and path.animatedNormalizedPathSegList
        var segments = path.pathSegList;
        for( var i = 0; i < segments.numberOfItems; ++i )
        {
            var pathSeg = segments.getItem(i);
            // http://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathSeg
            switch( pathSeg.pathSegType )
            {
                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                    // Handle subpaths and compound paths by creating a new path every
                    // time we see a move-to.
                    // NOTE: This will be wrong if there is a close-path *not* followed
                    //       by a move-to.
                    if( cubic_points.length > 0 )
                    {
                        append_path( cubic_points );
                    }
                    cubic_points = [ [ pathSeg.x, pathSeg.y ] ];
                    break;
                
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                    cubic_points.push( [ pathSeg.x1, pathSeg.y1 ] );
                    cubic_points.push( [ pathSeg.x2, pathSeg.y2 ] );
                    cubic_points.push( [ pathSeg.x, pathSeg.y ] );
                    break;
                
                default:
                    console.log( "We shouldn't see pathSeg.pathSegType: " + pathSeg.pathSegType );
                    break;
            }
        }
        // Append the final path.
        append_path( cubic_points );
        
        } );
    
    // createHandleUIForSVG() needs the largest closed path.
    var biggest_bbox_area = -1;
    gLargestPath = null;
    for( var i = 0; i < paths_info.length; ++i )
    {
        if( !paths_info[i].closed ) continue;
        
        if( paths_info[i].bbox_area > biggest_bbox_area )
        {
            biggest_bbox_area = paths_info[i].bbox_area;
            gLargestPath = paths_info[i].cubic_bezier_chain.slice(0);
        }
    }
    
    gSocket.send( "paths-info " + JSON.stringify( paths_info ) );
    
    // If we're debugging, update all points with the exact same thing we just loaded.
    // Nothing should change.
    if( kDebugging )
    {
        setTimeout( function() {
            var new_paths = [];
            for( var i = 0; i < paths_info.length; ++i )
            {
                new_paths.push( paths_info[i].cubic_bezier_chain );
            }
            updatePaths( new_paths );
            }, 100 );
    }
    
    if( kDebugging )
    {
        var total = 0;
        for( var i = 0; i < paths_info.length; ++i )
        {
            total += ( paths_info[i].cubic_bezier_chain.length - 1. ) / 3.;
        }
        console.log( "There are " + total + " cubic bezier curves total." );
    }
}
function sendHandlePositions()
{
    "use strict";
    
    var handle_positions = [];
    for( var i = 0; i < gHandles.length; ++i )
    {
        handle_positions.push( gHandles[i].pos );
    }
    
    gSocket.send( "handle-positions " + JSON.stringify( handle_positions ) );
}
function sendHandleTransformation( handle_index )
{
    sendHandleTransformations( [ handle_index ] );
}
function sendHandleTransformations( handle_indices )
{
    "use strict";
    
    if( handle_indices.length === 0 )
    {
        console.error( "sendHandleTransformations() with an empty array." );
        return;
    }
    
    var payload = [];
    for( var i = 0; i < handle_indices.length; ++i )
    {
        var handle_index = handle_indices[i];
        var M = gHandles[ handle_index ].transform;
        
        payload.push([
            handle_index,
            // According to http://www.w3.org/TR/SVG11/coords.html#EstablishingANewUserSpace
            // the elements of an SVG matrix are the first two rows of a 3x3 as follows.
            // (The third row is assumed to always be [ 0, 0, 1 ].)
            // This is all assuming that the matrix M is multiplied by a column
            // vector v = [[x][y][1]] on the right to get the new point v': M*v = v'
            [[ M.a, M.c, M.e ], [ M.b, M.d, M.f ]]
            ]);
    }
    
    gSocket.send( "handle-transforms " + JSON.stringify( payload ) );
}
function sendHandleDragFinished()
{
    gSocket.send( "handle-transform-drag-finished" );
}
function sendControlPointConstraintsChanged( path_index, segment_index )
{
    "use strict";
    
    gSocket.send( "control-point-constraint " + JSON.stringify( [ path_index, segment_index, gPathsControlPointConstraints[ path_index ][ segment_index ] ] ) );
}
function sendWeightTypeChanged()
{
    "use strict";
    gSocket.send( "enable-bbw " + JSON.stringify( $('#isBBWEnabled').prop('checked') ) );
}
function sendIfUsingArcLengthParameterization()
{
    "use strict";
    gSocket.send( "enable-arc-length " + JSON.stringify( $('#usingArcLengthParameterization').prop('checked') ) );
}
function throttleHandleTransformationsUntilUpdate()
{
    var gSendHandleTransformationsWait = null;
    
    // Throttle sendHandleTransformations, so that it doesn't send again until it gets new positions.
    var sendHandleTransformations_raw = sendHandleTransformations;
    sendHandleTransformations = function( handle_indices )
    {
        // It's important that we check for an empty array
        // so that we don't wait for positions to be updated when
        // they never will.
        if( handle_indices.length === 0 ) return;
        
        if( gSendHandleTransformationsWait !== null )
        {
            // Remember which ones to send.
            for( var i = 0; i < handle_indices.length; ++i )
            {
                gSendHandleTransformationsWait[ handle_indices[i] ] = true;
            }
        }
        else
        {
            sendHandleTransformations_raw( handle_indices );
            gSendHandleTransformationsWait = {};
        }
    }
    
    // Patch updatePaths() to send any waiting transforms.
    var updatePaths_raw = updatePaths;
    updatePaths = function( new_paths_points )
    {
        updatePaths_raw( new_paths_points );
        
        var handle_indices = [];
        if( gSendHandleTransformationsWait !== null )
        {
            for( var handle_index in gSendHandleTransformationsWait )
            {
                handle_indices.push( parseInt( handle_index ) );
            }
        }
        
        gSendHandleTransformationsWait = null;
        sendHandleTransformations( handle_indices );
    }
}

function setupFileIO()
{
    "use strict";
    
    // In order to use jQuery event handling with drag-and-drop events,
    // we have to tell jQuery to include it:
    jQuery.event.props.push( "dataTransfer" );
    
    $(kDragDropFeedbackSelector).addClass( "empty" );
    
    $( window ).on( 'dragover', displayDroppable );
    // The dragenter and dragleave events are hard to use, because they fire when any child
    // element is entered. Instead, we use 'dragover' and let 'drop' take care of removing
    // the css classes.
    // $( window ).on( 'dragleave', function() { $(kDragDropFeedbackSelector).removeClass( "droppable not-droppable" ); } );
    
    $( window ).on( 'drop', function( evt ) {
        evt.preventDefault();
        
        $(kDragDropFeedbackSelector).removeClass( "droppable not-droppable" );
        
        if( !isDroppable( evt ) ) return;
        
        // In the first pass, parse SVG.
        for( var i = 0; i < evt.dataTransfer.files.length; ++i )
        {
            var file = evt.dataTransfer.files[i];
            if( file.type === 'image/svg+xml' )
            {
                var reader = new FileReader();
                reader.onloadend = function(evt) {
                    if (evt.target.readyState == FileReader.DONE) {
                        var svg_text = evt.target.result;
                        
                        $("#filename").text( file.name );
                        $("#filename").removeClass( "text-muted" );
                        
                        loadSVG( svg_text );
                        
                        $("#save-button").prop( "disabled", false );
                    }
                    }
                
                reader.readAsBinaryString(file);
            }
        }
        
        // In the second pass, load associated JSON.
        for( var i = 0; i < evt.dataTransfer.files.length; ++i )
        {
            var file = evt.dataTransfer.files[i];
            if( file.type === 'application/json' )
            {
                var reader = new FileReader();
                reader.onloadend = function(evt) {
                    if (evt.target.readyState == FileReader.DONE) {
                        var globals = JSON.parse( evt.target.result );
                        loadGlobals( globals );
                    }
                    }
                
                reader.readAsBinaryString(file);
            }
        }
        } );
    
    $("#save-button").click( function() {
        
        function save_SVG_as( svg_to_save, filename )
        {
            if( svg_to_save.length === 0 )
            {
                console.error( "No SVG to save. This button should be disabled." );
                return;
            }
            
            // NOTE: svg_to_save[0].outerHTML does not seem to work with SVG in Chrome.
            //       It is also less correct, because we lose the header comments
            //       that were in the file before the <svg> tag.
            var blob = new Blob([ svg_to_save.parent().html() ], {type: "image/svg+xml"});
            saveAs( blob, filename );
        }
        
        // Save the main SVG file.
        var svg = $("#svg-file > svg");
        var filename = $('#filename').text();
        save_SVG_as( svg, filename );
        
        // Also save the globals
        if( kSaveGlobals )
        {
            var blob = new Blob([ globalsToJSON() ], {type: "application/json"});
            saveAs( blob, filename.replace( /\.svg$/, "" ) + "-deformation.json" );
        }
        
        // Also save the decorations.
        if( $('#kSaveDecorations').prop('checked') )
        {
            $('#svg-holder').children().each( function( index, child ) {
                if( child.id === 'svg-file' ) return true;
                
                var decorations = $(child).children("svg");
                if( decorations.length === 0 ) return true;
                
                save_SVG_as( decorations, filename.replace( /\.svg$/, "" ) + "-" + child.id + ".svg" );
                } );
        }
        } );
}

function globalsToJSON()
{
    "use strict";
    
    var globals = {};
    globals.gInputSVGText = gInputSVGText;
    globals.isBBWEnabled = $( "#isBBWEnabled" ).prop( "checked" );
    globals.gPathsControlPointConstraints = gPathsControlPointConstraints;
    globals.gHandles = gHandles;
    
    return JSON.stringify( globals );
}
function loadGlobals( globals )
{
    if( globals.gInputSVGText !== undefined ) loadSVG( globals.gInputSVGText );
    
    /// Copy to globals.
    $( "#isBBWEnabled" ).prop( "checked", globals.isBBWEnabled );
    
    // 0 Send BBW weight status already.
    //   We send this first, because that way less re-computation has to be done.
    sendWeightTypeChanged();
    
    gPathsControlPointConstraints = globals.gPathsControlPointConstraints;
    
    /// Now send the new data. The server should check whether anything really changed.
    // 1 Send control point constraints.
    for( var path_index = 0; path_index < gPathsControlPointConstraints.length; ++path_index )
    {
        var segments = gPathsControlPointConstraints[ path_index ];
        for( var segment_index = 0; segment_index < segments.length; ++segment_index )
        {
            sendControlPointConstraintsChanged( path_index, segment_index );
        }
    }
    
    // 2 Send handles.
    var all_indices = [];
    for( var handle_index = 0; handle_index < globals.gHandles.length; ++handle_index )
    {
        var handle = globals.gHandles[ handle_index ];
        createHandleAtPosition( handle.pos[0], handle.pos[1] );
        setHandleTransform( handle_index, handle.transform )
        
        all_indices.push( handle_index );
    }
    sendHandlePositions();
    sendHandleTransformations( all_indices );
}
function loadSVG( svg_text )
{
    // Reset global variables.
    gInputSVGText = svg_text;
    gPathsControlPointConstraints = null;
    gLargestPath = null;
    gHandles = [];
    $( "#isBBWEnabled" ).prop( "checked", true );
    $( "#usingArcLengthParameterization" ).prop( "checked", false );
    
    // Attach the SVG to its node.
    $('#svg-file').html( svg_text );
    
    // Remove the "empty" visual indicator.
    $(kDragDropFeedbackSelector).removeClass( "empty" );
    
    // Set the width and height of the SVG area.
    var svg_holder = $('#svg-holder');
    
    /*
    // Get the actual SVG dom element with [0] rather than a jquery object.
    // UPDATE: This gets the bounding box size of the contents, not the size of the actual
    //         SVG-defined viewport, which is what is used for drawing.
    var svg = $('#svg-file > svg')[0];
    svg_holder.width( svg.getBBox().width );
    svg_holder.height( svg.getBBox().height );
    */
    
    var svg = $('#svg-file > svg');
    svg_holder.width( svg.width() );
    svg_holder.height( svg.height() );
    
    // Normalize SVG paths by converting them entirely to cubic bezier.
    normalizeSVG();
    
    // Send SVG to the backend.
    sendPathsForPrecomputation();
    
    // Setup UI
    createUIForSVG();
}

function normalizeSVG()
{
    // Iterate over all paths, replacing them with normalized versions of themselves.
    var svg = $('#svg-file path').each( function( index, path ) {
        // When a path is closed, Snap drops the final Z and adds a
        // cubic bezier line connecting the last and first point.
        // That is unnecessary when the last and first point were already equal.
        // Check for this case and remove Z commands where they are unnecessary.
        // NOTE: This handles subpaths and compound paths.
        
        // We need absolute points in order to do this check.
        path.setAttribute( 'd', Snap.path.toAbsolute( path.getAttribute('d') ).toString() );
        
        var segments = path.pathSegList;
        var moveSeg;
        for( var i = 0; i < segments.numberOfItems; ++i )
        {
            var pathSeg = segments.getItem(i);
            // http://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathSeg
            switch( pathSeg.pathSegType )
            {
                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                    moveSeg = pathSeg;
                    break;
                
                case SVGPathSeg.PATHSEG_CLOSEPATH:
                    // Remove the close-path command if we close a path
                    // but the path has already closed itself
                    // NOTE: This works even if the close-path immediately follows the move-to.
                    // Q: Is it OK that we store the moveSeg, even though we call removeItem()?
                    // A: Yes, it works fine.
                    // UPDATE: If the path has horizontal line and vertical line,
                    //         then we have to look farther back to find the
                    //         final X and Y coordinates.
                    // var lastPathSeg = segments.getItem(i-1);
                    var lastX, lastY;
                    {
                        for( var ii = i-1; ii >= 0; --ii )
                        {
                            var lastPathSeg = segments.getItem(ii);
                            if( lastPathSeg.x !== undefined )
                            {
                                lastX = lastPathSeg.x;
                                break;
                            }
                        }
                        for( var ii = i-1; ii >= 0; --ii )
                        {
                            var lastPathSeg = segments.getItem(ii);
                            if( lastPathSeg.y !== undefined )
                            {
                                lastY = lastPathSeg.y;
                                break;
                            }
                        }
                    }
                    if( lastX === moveSeg.x && lastY === moveSeg.y )
                    {
                        segments.removeItem(i);
                        // We are removing a path segment, so decrement i by one,
                        // since the for loop will increment it.
                        i -= 1;
                    }
                    break;
            }
        }
        
        // Snap.path.toCubic() converts paths entirely to absolute cubic beziers.
        // The built-in SVG normalizedPathSegList leaves behind lines (and
        // converts arc to lots of short lines),
        // while Snap converts lines and approximates arcs with bezier curves.
        path.setAttribute( 'd', Snap.path.toCubic( path.getAttribute('d') ).toString() );
        } );
}

function createUIForSVG()
{
    console.log( "createUIForSVG()" );
    
    createConstraintUIForSVG();
    createHandleUIForSVG();
    createDeformedBezierUIForSVG();
}
function createConstraintUIForSVG()
{
    // Duplicate the loaded SVG, so we get the right viewport, and then clear its contents.
    $( '#svg-overlay-constraints' ).html( $('#svg-file > svg').clone().empty() );
    var ui = Snap( '#svg-overlay-constraints > svg' );
    ui.clear();
    
    gPathsControlPointConstraints = [];
    
    disableControlPointControls();
    
    // Handle subpaths and compound paths. Store path_index and segment_index separately from the raw path index and segment index.
    var new_path_index = -1;
    var new_segment_index = 0;
    
    // Get the paths from the original SVG.
    var paths = $( '#svg-file > svg path' );
    
    // For each path, make a small clickable circle that brings up a popup menu.
    paths.each( function( index, path ) {
        
        // Add a dotted-line path.
        var path_copy = ui.path( path.getAttribute('d') );
        path_copy.attr({
            class: 'undeformed-curve',
            fillOpacity: 0.,
            stroke: "#bbb",
            strokeWidth: 3.,
            strokeDasharray: "10,10"
            });
        
        /// Adapted from: http://stackoverflow.com/questions/8053487/scripting-path-data-in-svg-reading-and-modifying
        // http://www.w3.org/TR/SVG/paths.html#__svg__SVGAnimatedPathData__normalizedPathSegList
        // See also path.pathSegList and path.animatedPathSegList and path.animatedNormalizedPathSegList
        var segments = path.pathSegList;
        
        function createTangents( pathSeg, lastSeg )
        {
            var line_attrs = {
                class: 'control-point-tangents',
                stroke: "#000",
                strokeWidth: 2.
                };
            ui.line( lastSeg.x, lastSeg.y, pathSeg.x1, pathSeg.y1 ).attr( line_attrs );
            ui.line( pathSeg.x, pathSeg.y, pathSeg.x2, pathSeg.y2 ).attr( line_attrs );
            
            var circle_attrs = {
                class: 'control-point-inner',
                fill: "#da5555",
                stroke: "#000",
                strokeWidth: 2.
                };
            ui.circle( pathSeg.x1, pathSeg.y1, 5. ).attr( circle_attrs );
            ui.circle( pathSeg.x2, pathSeg.y2, 5. ).attr( circle_attrs );
        }
        function createControlPointHandle( path_index, segment_index, pathSeg )
        {
            gPathsControlPointConstraints[ path_index ][ segment_index ] = { 'fixed': false, 'continuity': 'C0' };
            
            var c = ui.circle( pathSeg.x, pathSeg.y, 10. );
            c.attr({
                class: 'control-point-handle',
                fill: "#5555da",
                stroke: "#000",
                strokeWidth: 2.
                });
            
            c.click( function() {
                // Reset colors of all circles.
                $('#svg-overlay-constraints .control-point-handle').attr( "fill", '#5555da' );
                
                // If the point is currently selected, deselect it.
                if( controlPointIsSelected( path_index, segment_index ) )
                {
                    disableControlPointControls();
                }
                else
                {
                    // Set up controls for the control point.
                    setupControlPointControls( path_index, segment_index );
                    
                    // Set color of selected circle.
                    c.attr({ fill: '#da5555' });
                }
                } );
        }
        
        for( var i = 0; i < segments.numberOfItems; ++i )
        {
            var pathSeg = segments.getItem(i);
            var moveSeg;
            // http://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathSeg
            switch( pathSeg.pathSegType )
            {
                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                    gPathsControlPointConstraints.push( [] );
                    new_path_index += 1;
                    new_segment_index = 0;
                    
                    // Q: Skip the first "move to" point if the path is closed?
                    // A1: Yes. Otherwise I have two sets of constraints for the same point.
                    // A2: <see the next case statement>
                    
                    // Store the move-to segment, to check for closed paths.
                    moveSeg = pathSeg;
                    
                    // if( 0 === i && segments.getItem( segments.numberOfItems - 1 ).pathSegType === SVGPathSeg.PATHSEG_CLOSEPATH ) break;
                    createControlPointHandle( new_path_index, new_segment_index, pathSeg );
                    break;
                
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                    createTangents( pathSeg, segments.getItem(i-1) );
                    
                    new_segment_index += 1;
                    // A2: No. Skip the last curveTo point, so that indexing is easier.
                    // We have to check whether ( we are the last path OR the next path is a move-to ) AND the curveTo point matches the moveTo point.
                    if( ( i+1 == segments.numberOfItems || segments.getItem( i + 1 ).pathSegType === SVGPathSeg.PATHSEG_MOVETO_ABS )
                        && ( pathSeg.x === moveSeg.x && pathSeg.y === moveSeg.y ) )
                    {
                        break;
                    }
                    createControlPointHandle( new_path_index, new_segment_index, pathSeg );
                    break;
                
                default:
                    console.log( "We shouldn't see pathSeg.pathSegType: " + pathSeg.pathSegType );
                    break;
            }
        }
        } );
    
    // Let's set the z-order of our elements now.
    // Bottom-to-top:
    $('.undeformed-curve').appendTo( '#svg-overlay-constraints > svg' );
    $('.control-point-tangents').appendTo( '#svg-overlay-constraints > svg' );
    $('.control-point-inner').appendTo( '#svg-overlay-constraints > svg' );
    $('.control-point-handle').appendTo( '#svg-overlay-constraints > svg' );
    // $( '#svg-overlay-constraints circle' ).appendTo( '#svg-overlay-constraints > svg' );
}
function createDeformedBezierUIForSVG()
{
    // This is fragile but should work.
    $( '#svg-overlay-beziers-deformed' ).html( $('#svg-overlay-constraints > svg').clone() );
    
    // Remove the dotted lines.
    $( '#svg-overlay-beziers-deformed .undeformed-curve' ).remove();
    
    // Change the size of the blue dots.
    $( '#svg-overlay-beziers-deformed circle.control-point-handle' ).attr('r',5);
}
function createHandleUIForSVG()
{
    // Duplicate the loaded SVG, so we get the right viewport, and then clear its contents.
    $( '#svg-overlay-handles' ).html( $('#svg-file > svg').clone().empty() );
    var ui = Snap( '#svg-overlay-handles > svg' );
    ui.clear();
    
    // We previously found the largest closed path. Use that to make sure handles
    // aren't created outside the shape.
    var clickable = null;
    if( gLargestPath !== null )
    {
        // If gLargestPath is not null, it is a closed cubic bezier chain.
        var path = "M" + gLargestPath[0][0] + " " + gLargestPath[0][1];
        for( var i = 1; i < gLargestPath.length; i += 3 )
        {
            path = path + " C";
            for( var j = 0; j < 3; ++j )
            {
                path = path + " " + gLargestPath[i+j][0] + " " + gLargestPath[i+j][1];
            }
        }
        clickable = ui.path( path );
        clickable.attr({ opacity: 0. });
    }
    else
    {
        // If we don't have any closed paths, users can click anywhere.
        clickable = ui;
    }
    
    disableHandleControls();
    
    clickable.click( function( evt ) {
        // TODO: Adding a handle is a slow operation. Maybe we should check if a modifier
        //       key is held down, and return if it's not.
        
        // Don't use the x,y that come in as the second and third parameters.
        // They are equivalent to evt.pageX and evt.pageY.
        var parent = $( '#svg-overlay-handles > svg' );
        var x = evt.pageX - parent.offset().left;
        var y = evt.pageY - parent.offset().top;
        
        createHandleAtPosition( x, y );
        sendHandlePositions();
        } );
}
// Creates a new handle. NOTE: It does not send the new handle position to the server.
// Do that yourself afterwards with the global function:
//     sendHandlePositions();
function createHandleAtPosition( x, y )
{
    "use strict";
    
    var ui = Snap( '#svg-overlay-handles > svg' );
    
    var kHandleRectEdge = 10;
    var kHandleRectRound = 2;
    
    // r0 represents the original position of the handle.
    // This has the side effect that a duplicate handle can't be made,
    // because the shape under this can't be clicked.
    var r0 = ui.rect( x - kHandleRectEdge/2, y - kHandleRectEdge/2, kHandleRectEdge, kHandleRectEdge, kHandleRectRound );
    r0.attr({
        fill: "#da55da",
        stroke: "#000",
        strokeWidth: 2.,
        opacity: .5
        });
    
    var r = ui.rect( x - kHandleRectEdge/2, y - kHandleRectEdge/2, kHandleRectEdge, kHandleRectEdge, kHandleRectRound );
    r.attr({
        fill: "#da55da",
        stroke: "#000",
        strokeWidth: 2.
        });
    
    var handle_index = gHandles.length;
    gHandles.push( { 'pos': [ x, y ], 'transform': new Snap.Matrix() } );
    setupHandleControls( handle_index );
    
	// Make a drag handler for the handle.
	// A variable for the mouse-down matrix.
	var M0;
	r.drag(
		// drag move
		function( dx, dy ) {
		    var M;
			var trans_type = $('#handle-widgets select').val();
			if( trans_type === "translation" ) 
			{
			    // Make a translated copy of the current transformation.
			    // UPDATE: It's not so simple, because rotations and scales
			    //         have already been applied.
				// M = M0.clone().translate( dx, dy );
				// M = M0.clone().translate( dx + (x - M0.x(x,y)), dy + (y - M0.y(x,y)) );
				M = M0.clone().add( M0.invert() ).translate( dx, dy ).add( M0 );
			}
			else if( trans_type === "rotation" )
			{
                // Rotate according to horizontal motion.
				var degrees = dx;
			    M = M0.clone().rotate( degrees, x, y );
			}
			else if( trans_type === "scaling" )
			{
			    // Scale according to horizontal motion.
			    var s = Math.exp( dx/100. );
			    M = M0.clone().scale( s, s, x, y );
			}
			else
			{
				console.error("undefined transformation type is chosen.")
			}
			
            // Update the SVG element.
            this.transform( M );
            
            // Update the global variable (and the HTML table).
            gHandles[ handle_index ].transform = M;
            setupHandleControls( handle_index );
            
            // Send the transform over the network.
            sendHandleTransformation( handle_index );
		},
		// drag start
		function() {
			// Store the current transform state.
			M0 = this.transform().localMatrix;
			
			// Setup the table when clicking on an already-created rect.
			setupHandleControls( handle_index );
		},
		function() {
		    // Let the backend know it can do some processing.
		    sendHandleDragFinished();
		} );
}
// Sets the transform for a handle.
// NOTE: This does not call sendHandleTransformation(). Call that yourself, afterwards.
function setHandleTransform( handle_index, M )
{
    var matrix = new Snap.Matrix( M.a, M.b, M.c, M.d, M.e, M.f );
    gHandles[ handle_index ].transform = matrix;
    var rect = $('#svg-overlay-handles > svg > rect')[ handle_index*2 + 1 ];
    Snap( rect ).transform( matrix );
}

function controlPointIsSelected( path_index, segment_index )
{
    return(
        parseInt( $('#path_index').text() ) === path_index &&
        parseInt( $('#segment_index').text() ) === segment_index
        );
}
function setupControlPointControls( path_index, segment_index )
{
    $('#path_index').text( path_index );
    $('#segment_index').text( segment_index );
    
    // We really only have to enable these controls the first time.
    var controls = $('#control-point-constraints');
    controls.removeClass( 'text-muted' );
    controls.find( 'select, input' ).prop( "disabled", false );
    
    var settings = gPathsControlPointConstraints[ path_index ][ segment_index ];
    controls.find( '[value=' + settings.continuity + ']' ).prop( 'selected', true );
    controls.find( 'input' ).prop( 'checked', settings.fixed );
}
function disableControlPointControls()
{
    $('#path_index').text( 'null' );
    $('#segment_index').text( 'null' );
    
    // We really only have to enable these controls the first time.
    var controls = $('#control-point-constraints');
    controls.addClass( 'text-muted' );
    controls.find( 'select, input' ).prop( "disabled", true );
}
function setupHandleControls( handle_index )
{
    $('#handle_index').text( handle_index );
    
    // We really only have to enable these controls the first time.
    var controls = $('#handle-widgets table');
    controls.removeClass( 'text-muted' );
    
    var inputs = controls.find( 'input' );
    
    var M = gHandles[ handle_index ].transform;
    inputs.eq(0).val( M.a );
    inputs.eq(1).val( M.c );
    inputs.eq(2).val( M.e );
    inputs.eq(3).val( M.b );
    inputs.eq(4).val( M.d );
    inputs.eq(5).val( M.f );
    
    inputs.prop( "disabled", false );
    
    // At the same time enable the transformation type choices
    var trans_choice = $('#handle-widgets select');
    trans_choice.prop( "disabled", false );
     
}
function disableHandleControls()
{
    $('#handle_index').text( 'null' );
    
    // We really only have to enable these controls the first time.
    var controls = $('#handle-widgets table');
    controls.addClass( 'text-muted' );
    controls.find( 'input' ).prop( 'disabled', true );
    controls.find( 'input' ).val( '?' );
    
    // At the same time disable the transformation type choices
    var trans_choice = $('#handle-widgets select');
    trans_choice.prop( "disabled", true );
}
function setupGlobalUI()
{
    /// Change handlers for control point constraints.
    $('#continuity').change( function() {
        
        var path_index = parseInt( $('#path_index').text() );
        var segment_index = parseInt( $('#segment_index').text() );
        
        gPathsControlPointConstraints[ path_index ][ segment_index ].continuity = this.value;
        
        sendControlPointConstraintsChanged( path_index, segment_index );
        } );
    
    $('#fixed').change( function() {
        var path_index = parseInt( $('#path_index').text() );
        var segment_index = parseInt( $('#segment_index').text() );
        
        gPathsControlPointConstraints[ path_index ][ segment_index ].fixed = this.checked;
        
        sendControlPointConstraintsChanged( path_index, segment_index );
        } );
    
    
    /// Change handler for handle transform inputs.
    $('#handle-widgets input').change( function() {
        var which = this.getAttribute( 'name' );
        var handle_index = parseInt( $('#handle_index').text() );
        var M = gHandles[ handle_index ].transform;
        
        M[which] = parseFloat( $(this).val() );
        setHandleTransform( handle_index, M );
        
        sendHandleTransformation( handle_index );
        } );
    
    
    /// Setup change callbacks for the toggles.
    $("#isBBWEnabled").change( function() {
        sendWeightTypeChanged();
    } );
    
    // Set it up and trigger it.
    $("#showTargetCurves").change( function() {
        var checked = $(this).prop('checked');
        $('#liveTargetCurves').prop( 'disabled', !checked );
        $('#svg-overlay-target').toggle( checked );
    } ).change();
    $("#showDeformedControlPoints").change( function() {
        var checked = $(this).prop('checked');
        if( checked )
        {
            // Update them in case they've changed.
            updateDeformedBezierOverlay();
        }
        $('#svg-overlay-beziers-deformed').toggle( checked );
    } ).change();
    $("#usingArcLengthParameterization").change( function() {
        var checked = $(this).prop('checked');
        sendIfUsingArcLengthParameterization();
        
    } );
    
    
    /// Switching modes between control point constraints and handles
    $('#handle-widgets').click( function() {
        // Set highlight state.
        $('#handle-widgets').addClass( 'background-selected' );
        $('#control-point-constraints').removeClass( 'background-selected' );
        
        // Hide/show the SVG layers.
        $( '#svg-overlay-constraints' ).hide();
        $( '#svg-overlay-handles' ).show();
        
        // Disable/enable controls
        // if( $('#handle_index').text() !== 'null' ) setupHandleControls( parseInt( $('#handle_index').text() ) );
        // $( '#control-point-constraints input, #control-point-constraints select' ).prop( 'disabled', true );
        disableControlPointControls();
        } );
    $('#control-point-constraints').click( function() {
        // Set highlight state.
        $('#handle-widgets').removeClass( 'background-selected' );
        $('#control-point-constraints').addClass( 'background-selected' );
        
        // Hide/show the SVG layers.
        $( '#svg-overlay-constraints' ).show();
        $( '#svg-overlay-handles' ).hide();
        
        // Disable/enable controls
        disableHandleControls();
        } );
    
    // The default tool is handle-widgets.
    $('#handle-widgets').click();
}


///
/// Initialization.
///
$(document).ready( function() {
    
    setupWebSocket();
    
    if( !kFakeWebSocket ) throttleHandleTransformationsUntilUpdate();
    
    setupFileIO();
    
    setupGlobalUI();
});
</script>
</body>
</html>
