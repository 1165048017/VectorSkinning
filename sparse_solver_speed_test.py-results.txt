The ## specifies which SVG file was used.
    'simple_closed' is a chain of four curves
    'pebble' is the same with the word "pebble" outlined in the interior
    'alligator' is alec's alligator

The '======> G1-and-A:' line says whether G1-and-A constraints were used, or just C1 and C0 constraints. When G1-and-A constraints are off (False), we can prefactor or invert the system matrix and just perform back substitution or matrix multiplication. When G1-and-A constraints are on (True), they require an iterative solution that changes the system matrix, so we can't prefactor. In theory we only need to re-do the numeric factorization, but if e.g. the constraint directions align with 0 then the sparsity pattern does change. Optimistically assuming that there would be no "extra" zeros in the initial system, I tested keeping the symbolic factorization between iterations (for cvxopt's umfpack, the only solver that exposes this) and it made no difference to performance, so I've left it off.

The first column is the time it takes to solve given new handle transforms. This is literally just measuring back substitution or matrix multiplication time when G1-and-A constraints are off, and otherwise it is measuring rebuilding and refactoring the system each time. The array at the end is the raw data, which was three runs of 100 transform updates.
The second column is which solver was used.
    numpy-inv means the dense system matrix was inverted once, and then multiplied each time a solution was needed. For G1-and-A True, the solution was invalidated immediately.
    numpy-solve means the dense system matrix was never inverted, and each time a solution was needed it was solved anew.
    cvxopt used the sparse matrix solver umfpack. (It also has an interface to cholmod, but cholmod was throwing up arithmetic errors. I thought it could handle, via LDL^T, systems like ours with lagrange multipliers that are symmetric but not positive definite.) Anyhow, this solver exposes the symbolic and numeric factorization.
    scipy used scipy's sparse matrix solver. I just looked it up, and it's also using umfpack. I thought it was something else. Scipy exposes the numeric but not sybmolic factorization.
The third column is which data structure was used to build the system.
    cvxopt is cvxopt's COO (triplet) matrix type
    scipy is scipy's list-of-lists matrix type. (It doesn't show up here because it's painfully slow, so I stopped testing it.)
    numpy is numpy's dense matrix type
The fourth column is a repetition of the SVG file.

## simple_closed
======> G1-and-A: False
time    solver      matrix  SVG             time-per-100-calls
0.0	    numpy-inv	cvxopt	simple_closed	[0.0494, 0.0571, 0.0629]
0.001	cvxopt		cvxopt	simple_closed	[0.0743, 0.0769, 0.0820]
0.001	cvxopt		numpy	simple_closed	[0.0644, 0.0828, 0.1108]
0.001	numpy-inv	numpy	simple_closed	[0.0509, 0.0713, 0.0780]
0.001	numpy-solve	cvxopt	simple_closed	[0.0624, 0.0851, 0.0947]
0.001	numpy-solve	numpy	simple_closed	[0.0794, 0.0839, 0.0946]
0.001	scipy		cvxopt	simple_closed	[0.0827, 0.0838, 0.0964]
0.001	scipy		numpy	simple_closed	[0.0575, 0.0758, 0.0960]
======> G1-and-A: True
0.006	numpy-inv	numpy	simple_closed	[0.6351, 0.6948, 0.7618]
0.007	numpy-inv	cvxopt	simple_closed	[0.7045, 0.8299, 0.8617]
0.007	numpy-solve	numpy	simple_closed	[0.7469, 0.7809, 0.9440]
0.008	cvxopt		cvxopt	simple_closed	[0.7618, 0.8063, 0.9067]
0.008	cvxopt		numpy	simple_closed	[0.7974, 0.9058, 0.9159]
0.008	numpy-solve	cvxopt	simple_closed	[0.8210, 0.8279, 0.8308]
0.008	scipy		cvxopt	simple_closed	[0.8173, 0.9501, 1.0496]
0.009	scipy		numpy	simple_closed	[0.8895, 1.0479, 1.0489]
## pebble
======> G1-and-A: False
0.012	numpy-inv	cvxopt	pebble			[1.2344, 1.2412, 1.2997]
0.012	numpy-inv	numpy	pebble			[1.2064, 1.4243, 1.6802]
0.013	cvxopt		cvxopt	pebble			[1.3285, 1.3291, 1.3356]
0.013	scipy		numpy	pebble			[1.2997, 1.3009, 1.3308]
0.014	cvxopt		numpy	pebble			[1.4072, 1.4204, 1.4387]
0.014	numpy-solve	cvxopt	pebble			[1.4447, 1.4518, 1.4807]
0.014	scipy		cvxopt	pebble			[1.3531, 1.4031, 1.4369]
0.015	numpy-solve	numpy	pebble			[1.4570, 1.5110, 1.5445]
======> G1-and-A: True
0.091	numpy-solve	numpy	pebble			[9.1128, 9.3582, 9.5010]
0.092	numpy-inv	numpy	pebble			[9.2142, 9.2276, 9.2523]
0.097	cvxopt		numpy	pebble			[9.6756, 9.7573, 9.8593]
0.1	    numpy-inv	cvxopt	pebble			[10.0097, 10.0352, 10.0577]
0.101	numpy-solve	cvxopt	pebble			[10.0851, 10.1082, 11.3308]
0.102	cvxopt		cvxopt	pebble			[10.1702, 10.2452, 10.2600]
0.102	scipy		numpy	pebble			[10.2285, 10.2499, 10.2724]
0.108	scipy		cvxopt	pebble			[10.8380, 10.8684, 11.0068]
## alligator
======> G1-and-A: False
0.132	scipy		numpy	alligator		[13.1567, 13.2093, 13.2450]
0.135	numpy-inv	numpy	alligator		[13.5203, 13.6079, 13.6927]
0.137	scipy		cvxopt	alligator		[13.6671, 13.7211, 13.7473]
0.139	cvxopt		cvxopt	alligator		[13.9417, 14.0502, 14.1090]
0.139	cvxopt		numpy	alligator		[13.8557, 14.0238, 14.0473]
0.139	numpy-inv	cvxopt	alligator		[13.8981, 14.1738, 16.3135]
0.963	numpy-solve	cvxopt	alligator		[96.3444, 96.7197, 96.8196]
1.053	numpy-solve	numpy	alligator		[105.3495, 105.9483, 108.1606]
======> G1-and-A: True
0.865	scipy		numpy	alligator		[86.5309, 86.5835, 86.6477]
0.958	cvxopt		numpy	alligator		[95.8238, 100.4834, 102.6977]
1.103	cvxopt		cvxopt	alligator		[110.2716, 110.3006, 111.3150]
1.109	scipy		cvxopt	alligator		[110.9220, 111.0126, 111.0997]
2.258	numpy-solve	numpy	alligator		[225.7527, 225.9823, 226.6220]
2.498	numpy-solve	cvxopt	alligator		[249.7971, 250.6023, 253.0903]
2.573	numpy-inv	numpy	alligator		[257.2758, 258.4157, 262.6522]
2.997	numpy-inv	cvxopt	alligator		[299.7299, 300.0921, 300.2833]
